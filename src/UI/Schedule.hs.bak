module UI.Schedule
  ( render
  ) where

import Brick (strWrap)
import qualified Brick.AttrMap as A (applyAttrMappings)
import qualified Brick.Types as T (Padding(..), Widget)
import Brick.Util (on)
import qualified Brick.Widgets.Border as B (border, borderAttr, hBorder)
import Brick.Widgets.Border.Style (unicodeRounded)
import qualified Brick.Widgets.Center as C (center, hCenter)
import Brick.Widgets.Core
  ( (<+>)
  , (<=>)
  , padBottom
  , padLeft
  , str
  , updateAttrMap
  , vBox
  , withAttr
  , withBorderStyle
  )
import Model (State(..), Widget(..), Task(..))
import Data.Bool (bool)
import qualified Data.Time.Format as F (defaultTimeLocale, formatTime)
import Data.Time.LocalTime (ZonedTime(..))
-- import qualified Graphics.Vty as V (black, magenta)

render :: State -> T.Widget Widget
render s =
  C.hCenter $
  vBox (drawEntries s `lor` [C.center $ str "No Task Done Yet"])

drawEntries :: State -> [T.Widget Widget]
drawEntries State {_tasks = tasks} =
  map (\task -> drawEntry task) tasks



drawEntry :: Task -> T.Widget Widget
drawEntry t =
  focusedStyle True . withBorderStyle unicodeRounded . B.border $
  (sessionTitle <+> time) <=> B.hBorder <=> notes -- <=> (hours' <+> cost)
  where
    sessionTitle = (withAttr bold . str . title) t
    time = padLeft T.Max . str $ (formatTime (startTime t))++" to "++(formatTime (endTime t))
    notes = padBottom (T.Pad 1) (strWrap $ notes t)
    -- hours' = clockStyle e . str . asHours $ hours t
    -- cost = padLeft T.Max . str $ "$" ++ show ((round $ hours e * rate e) :: Int)


lor :: (Foldable f) => f a -> f a -> f a
lor a b = bool a b (null a)

formatTime :: ZonedTime -> String
formatTime = F.formatTime F.defaultTimeLocale "%F %R"